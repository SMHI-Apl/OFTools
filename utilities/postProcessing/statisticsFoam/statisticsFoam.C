/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
  \\    /   O peration     |
  \\  /    A nd           | Copyright (C) 1991-2004 OpenCFD Ltd.
  \\/     M anipulation  |
  -------------------------------------------------------------------------------
  License
  This file is part of OpenFOAM.

  OpenFOAM is free software; you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation; either version 2 of the License, or (at your
  option) any later version.

  OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  for more details.

  You should have received a copy of the GNU General Public License
  along with OpenFOAM; if not, write to the Free Software Foundation,
  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

  Application
  statisticsFoam

  Description
\*---------------------------------------------------------------------------*/
#include "fvCFD.H"
#include "OSspecific.H"
#include "ConcFileArchive.H"
#include "tsRow.H"
#include "timeSeries.H"
#include "argList.H"
#include <vector>
#include <string>
#include <sstream>
#include <fstream>
#include "PtrList.H"
#include <iostream>

// #include <cmath>
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

double STD_PRES = 101.325; // kPa
double STD_TEMP = 273.15;  // Kelvin
double MOL_VOL_AIR = 22.41400; // L/mol


// const fileName getOutputDir() const
// {
//     // Create the output folder if it doesn't exist yet
//     fileName outputDir;
//     if (Pstream::parRun())
//     {
//         outputDir = mesh_.time().path()/".."/"debug";
//     }
//     else
//     {
//         outputDir = mesh_.time().path()/"debug";
//     }
//     if (!isDir(outputDir))
//     {
//         mkDir(outputDir);
//     }
//     return outputDir;
// }

scalar microg2ppb(scalar mol_weight, scalar temp=273.15, scalar pres=101.325)
{
  /*
    Return factor for conversion from microg/m3 to ppb (mol)
    std pressure is set to 101.325 kPa
    std temp is set to 0 deg C
    @param temp: Temperature in Kelvin
    @param pres: pressure in kPa
    @param mol_weight: molar weight of substance to be converted
  */
  return (MOL_VOL_AIR * temp * STD_PRES) / (46.0 * STD_TEMP * pres);
}


scalar OSPMScheme(scalar temp, scalar glob, scalar O3_b,
	       scalar NO2_b, scalar NOx_b, scalar NOx_v,
	       scalar fd=0.05, scalar tau=1600)
{
  /*
    Converts NOx to NO2 using Berkovitz OSPM Scheme,
    Taken from 'NO2 chemistry scheme in OSPM and other Danish models'
    Note prepared by Ruwim Berkowicz, Matthias Ketzel et. al. March 2011
    Originally described in:
    Ref. Hertel,O. and Berkowicz, R.(1989) Modeling NO2
    concentrations in a street cayon DMU Luft A-131.

    temp: temperature [K], scalar
    glob: global radiation [W/m^2], scalar
    O3_b: background conc. of O3 [ppb], scalar
    NO2_b: background conc. of NO2 [ppb], scalar
    NOx_v: conc NOx generated by local/urban sources [ppb], numpy array
    NOx_b: background NOx conc. [ppb], scalar
    fd: fraction of NOx directly emitted as NO2, scalar
    tau: Mixing timescale [s], scalar
  */

  //Tk is temperature in Kelvin
  // k1 represents reation rate for NO+O3 -> NO2
  scalar k1  = 5.38e-2 * Foam::exp(scalar(-1430. / temp));
  // J represents rate of NO2 reduction by uv-light
  scalar J = 0.0;
  if(glob > 1)
    J = 0.8e-3 * Foam::exp(-10. / glob) + 7.4e-6 * glob;
  scalar R = J / k1;
  scalar D = 1.0 / (k1 * tau);
  scalar NOx_tot = NOx_v + NOx_b;

  // Direct emission of NO2 is estimated as a
  // constant fraction of NOx emissions
  scalar NO2_v = NOx_v * fd;

  scalar NO2_n = NO2_v + NO2_b;
  scalar NO2_o = NO2_n + O3_b;
  scalar B = NOx_tot + NO2_o + R + D;
  scalar NO2_urb = 0.5 * (B - Foam::sqrt(B * B - 4 * (NOx_tot * NO2_o + NO2_n * D)));
  
  // O3_urb=NO2_o-NO2_urb
  return NO2_urb;
}


int main(int argc, char *argv[])
{
  
#   include "setRootCase.H"
#   include "createTime.H"
#   include "createMesh.H"
#   include "readStatisticalData.H"
#   include "readEmissions.H"  
#   include "createTimeSeries.H"
#   include "createFields.H"
  // * ** * * * * * * * * * * * * * * * * * * * * * * //  
  
  //Loops over all hours, calculating a weight corresponding to the current meteorology and emissions
  //The weights are stored in a timeseries with one column per file in the ConcFileArchive 
  Info<<"Loops over all hours to calulate weights for dispersion cases"<<endl;
  
  emisHour=emisTS.rows.begin();
  Info<<"Nrows emis:"<<emisTS.nrows<<endl;
  Info<<"Nrows met:"<<metTS.nrows<<endl;
  
  for(hour=metTS.rows.begin();hour!=metTS.rows.end();hour++)
    {
      //Gets the vector with weights caused by the meteorology
      //(linear interpolation between windspeeds, gaussian wdir variation with std sigma during single hours)
      std::vector<double> metWeights = ca.getConcMetWeights(
          (*hour).data[wspeedInd],(*hour).data[wdirInd],(*hour).data[sigmaInd]
      );
      std::vector<double> emisWeights(metWeights.size(),0);
      std::vector<double> concNameWeights;
      
      /*
          Iterates over all concNames in the ConcFileArchive.
          
          Gets a weight vector with a weight for each ConcFileArchive
          (weight=1 if the file refers to the current concName, otherwise 0).
          
          For each concName the emission is also extracted from the emission
          timeseries and multiplied with the weight vector to give an emission weight vector.
          
          The resulting emission weights are summed over all concNames
          to get a complete emission weight vector
          
          Finally the emission weight vector is multiplied with the meteorological
          weight vector to give a complete weight vector
          
          The emission timeseries is presumed to be in units mg/s 
          (a conversion is made to match the unit emission of 1 g/(s sourceGroup)
          on which the concentration fields are based)
      */
      std::vector<std::string>::iterator concName;
      for(concName=ca.concNames.begin();concName!=ca.concNames.end();concName++)
        {
          concNameWeights=ca.getConcNameWeights(*concName);
          int concNameInd=emisTS.getColInd(*concName);
          if(concNameInd==-1)
            {
              Info<<"Error: parameter "
                  <<*concName
                  <<" not found in timeseries header"
                  <<endl;

              FatalErrorIn(args.executable())
                  << "Error: parameter "
                  << *concName
                  <<" not found in timeseries header"
                  << exit(FatalError);
            }
          emisWeights=add(
              emisWeights,multi(concNameWeights,(*emisHour).data[concNameInd]/1000.0)
          );
        }
      tsRow hourWeights(
          (*hour).year, (*hour).month, (*hour).day, (*hour).hour,
          multi(metWeights,emisWeights)
      );  
      weightTS.appendRow(hourWeights);

      tsRow debugWeightRow(
          (*hour).year, (*hour).month, (*hour).day, (*hour).hour,metWeights
      );
      debugTS.appendRow(debugWeightRow);
      // Info<<"emissions are: "<<emisHour->year<<"-"
      // <<emisHour->month<<"-"<<emisHour->day<<" "<<emisHour->hour<<": "<<endl;
      emisHour++;
  }
  Info<<"Calculated emission weights"<<endl;
  if (Pstream::master())
  {
      weightFid.open(weightFile.c_str());
      if(!weightFid.is_open())
          FatalErrorIn(args.executable())
              << "Could not open weight debug file"<< exit(FatalError);
      weightFid<<debugTS;
      weightFid.close();
  }
  volScalarField& hourlyAvg=statFields[0];
  
  Info<<"Preprocessing of met-data and emissions ready!"<<endl;
  Info<<"Starting loop over cells!..."<<endl;

  //Factor to convert from massfraction to ug/m3
  //temporary fix with hard-coded air density
  double typeConversionFactor=1.225*1.0e9;



  qcFid.open(qcFileName.c_str(), ios_base::app);
  if(!qcFid.is_open())
      FatalErrorIn(args.executable())
          << "Could not open quality control file for max conc"<< exit(FatalError);

  //Initializing progress counters
  scalar cellCounter=1;
  label nCells=hourlyAvg.internalField().size();
  scalar doneProc1=0;
  scalar doneProc2=0;
  int probesDone=0;
  
  //Iterating over all internal cells
  Info<<" Number of cells is: "<<nCells<<endl;
  forAll(hourlyAvg.internalField(),celli)
    {
      //Progress counter
      doneProc2=cellCounter/scalar(nCells)*100.0;
      if(doneProc2-doneProc1>1)	
	{
	  Info<<" Done "<<int(doneProc2)<<" %"<<endl;
	  doneProc1=doneProc2;
	}
      //Info<<" Done "<<doneProc2<<" %"<<endl;

      //Getting cell values from archived conc fields
      if(!args.parRunControl().parRun()) {
	// if serial, read one cell at a time from file (miminum memory footprint)
	ca.nextCellValue();
	}
      else {
	// if parallel run, read from volScalarFields using standard OpenFOAM routines
	for(label concFieldInd=0;concFieldInd < nConcFields;concFieldInd++)
	  ca.concs[concFieldInd]=concFields[concFieldInd].internalField()[celli];
      }

      //Checking if cell label match any of the probe cell labels
      int foundProbe=0;
      int probeNr = 0;
      PtrList<timeSeries>::iterator probeIter=probeTsList.begin();
      for(;probeIter!=probeTsList.end();probeIter++) {
          if(probeCells[probeNr]==celli)
          {
              std::cout<<"Found probe cell, writing timeseries to probes dir"<<"\n";
	      foundProbe=1;
	      probesDone++;              
	      break;
          }
          probeNr++;
      }

      //Initializing average calculations
      double sumConc=0.0;
      double nHours=0.0;
   
      //Start timeseries calculations for current cell
      if(write3DFields or foundProbe)
	{

	  bgHour = bgTS.rows.begin();
	  concHour = concTS.rows.begin();
	  metHour = metTS.rows.begin();

	  if(foundProbe)
              probeHour=(*probeIter).rows.begin();

	  for(hour=weightTS.rows.begin();hour!=weightTS.rows.end();hour++)
	    {
	      (*concHour).data[0]=sum(multi((*hour).data,ca.concs))*typeConversionFactor;	      
	      //Checking that calculated concentration is not greater than maxConc
	      //if so writing individual concentrations to file for closer checking
	      if( (*concHour).data[0]>maxConc or ( foundProbe and hour==weightTS.rows.begin() ) )
              {
		  std::vector<ScalarFoamFile>::iterator concFile;
                  
		  if(foundProbe)
                  {
                      std::cout<<"Quality control data written to file: "<<qcFileName<< "\n";
		      qcFid<<"Probe name: "<<(*probeIter).header[0]<<"\n";
                  }
		  else
                      std::cout << "Warning: "
                          << "There are invalid concentration fields, sum of conc in cell "
                          << cellCounter<<" is: " << (*concHour).data[0]
                          << ", max allowed conc is set to: " << maxConc
                          << "summary written to: " << qcFileName << "\n";
		  
		  qcFid << "Time is: " << hour->year << "-" << hour->month
                      << "-" << hour->day << "-" << hour->hour << "\n";
                  
		  qcFid << "Filename\torgConc\tweight\ttypeConversion\ttotConc\n";
		  int concInd=0;
		  for(concFile=ca.fileVec.begin();concFile!=ca.fileVec.end();concFile++)
		    {
		      qcFid << concFile->getDirName() << " " << concFile->fileName << "\t";
		      qcFid << ca.concs[concInd] << "\t";
		      qcFid << (*hour).data[concInd] << "\t";
		      qcFid << typeConversionFactor << "\t";
		      qcFid << ca.concs[concInd]*(*hour).data[concInd]*typeConversionFactor << "\n"; 
		      concInd++;
		    }
		}
	      

	      (*concHour).year=(*hour).year;
	      (*concHour).month=(*hour).month;
	      (*concHour).day=(*hour).day;
	      (*concHour).hour=(*hour).hour;

	      
	      if(background){
		if(NO2_conversion) {
                  scalar temp = (*metHour).data[tempInd] + 273.15;
		  scalar glob = (*metHour).data[globInd];
		  scalar NO2_b = (*bgHour).data[NO2bInd] * microg2ppb(46.0, temp);
		  scalar NOx_b = (*bgHour).data[NOxbInd] * microg2ppb(46.0, temp);
		  scalar O3_b = (*bgHour).data[O3bInd] * microg2ppb(48.0, temp);
		  scalar NOx =  (*concHour).data[0] * microg2ppb(46.0, temp);
		  scalar NO2 = OSPMScheme(temp, glob, O3_b, NO2_b, NOx_b, NOx, fd, tau);
		  (*concHour).data[0] = NO2 / microg2ppb(46.0, temp);
		}
		else
		  (*concHour).data[0]+=(*bgHour).data[0];
	      }
	      
	      sumConc+=(*concHour).data[0];
	      nHours+=1.0;

	      if(foundProbe)
		{
		  (*probeHour).data[probeNr]=(*concHour).data[0];
		  probeHour++;
		}

	      bgHour++;
	      concHour++;
	      metHour++;
	    }
	  cellCounter++;
	  //std::ofstream testOut2;
	  //testOut2.open("/local_disk/dsegerss/OpenFOAM/dsegerss-1.3/run/slbProject/Hornsgatan_test/testOut2.txt");
	
	  if(probesDone==int(probeCells.size()) and not write3DFields)
	    break;          
	}
      
      if(write3DFields)
	{
	  if(indDailyAvgPerc)
	    {
	      timeSeries dailyAvgTS;
	      dailyAvgTS=concTS.dailyAverage(int(nValidsForDaily));
	      dailyAvgTS.header.push_back("dailyAverage");
	      dailyAvgTS.sort();      
	      statFields[indDailyAvgPerc].internalField()[celli]=dailyAvgTS.percentile(dailyAvgPercentile);
	      
	    }

	  if(indDailyMaxPerc)
	    {
	      
	      timeSeries dailyMaxTS;
	      dailyMaxTS=concTS.dailyMax(int(nValidsForDaily));
	      dailyMaxTS.header.push_back("dailyMax");
	      dailyMaxTS.sort();
	      statFields[indDailyMaxPerc].internalField()[celli]=dailyMaxTS.percentile(dailyMaxPercentile);
	    }

	  if(indHourlyPerc)
	    {
	      concTS.sort();
	      //statFields[indHourlyPerc].internalField()[celli]=concTS.percentile(hourlyPercentile);;
	     
	      //Debugging
	      scalar cellHourlyPerc=concTS.percentile(hourlyPercentile);
	      statFields[indHourlyPerc].internalField()[celli]=cellHourlyPerc;
	      if(cellHourlyPerc>1.0e3)
	      	{
                    std::cout<<"Cell index for hourly percentile > 10000 is: "<< cellCounter-1<<endl;
                    int last_ind=concTS.nrows-1;
                    Info<<"Max value date is: "
                        <<concTS.getYear(last_ind)
                        <<"-"<<concTS.getMonth(last_ind)
                        <<"-"<<concTS.getDay(last_ind)
                        <<" "<<concTS.getHour(last_ind)
                        <<" value:"<< concTS.getValue(last_ind)<<endl;
	      	}
              
	    }
  

	  hourlyAvg.internalField()[celli]=sumConc/nHours;
	}
      cellCounter++;
    }

  qcFid.close();

  if(write3DFields)
    {
      //Writing results
      //      hourlyAvg=hourlyAvg;
      hourlyAvg.write();
      
      if(indHourlyPerc)
	statFields[indHourlyPerc].write();
      
      if(indDailyAvgPerc)
	statFields[indDailyAvgPerc].write();


      if(indDailyMaxPerc)
	statFields[indDailyMaxPerc].write();
    }

  for(PtrList<timeSeries>::iterator probeIter=probeTsList.begin();
      probeIter!=probeTsList.end();probeIter++) {
      OStringStream probeFileNameStream;
      probeFileNameStream << word(probeDir) << "/" << word((*probeIter).header[0]) <<".csv";
      std::cout<<"probe file is: "<<probeFileNameStream.str()<<"\n";
      std::ofstream probeFid;
      probeFid.open(probeFileNameStream.str().c_str());
      if(!probeFid.is_open())
          FatalErrorIn(args.executable())
              << "Could not open probe output file"<< exit(FatalError);
      
      probeFid<< *probeIter;
      probeFid.close();
  }

  Info<< "statisticsFoam finished successfully\n" << endl;
  return(0);
}

// ************************************************************************* //
